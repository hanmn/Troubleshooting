If your customer sees an error similar to:
	 Could not load file or assembly 'file:///C:\TEMP\Service-Fabric-master\Service-Fabric-master\Scripts\ServiceFabricRPHelpers\System.Fabric.CSMTemplate\System.Fabric.CSMTemplate.dll' or one of its dependencies. Operation is not
	supported. (Exception from HRESULT: 0x80131515)

This is possibly caused by downloading module from internet.  If so you need to unblock the dll. (Browse to Dll, right-click, select Properties, and check ‘unblock’ on the General tab.

You can do the following to get thumb of the cert to  base64 string and put in your clipboard:
[System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes("C:\path\to\certificate.pfx")) | clip
 


#Requires -Version 3.0
Param(
	[string] [Parameter(Mandatory=$true)] $location,
	[string] [Parameter(Mandatory=$true)] $clusterName,
	[string] [Parameter(Mandatory=$true)] $certVersion,
	[string] [Parameter(Mandatory=$true)] $outputPath,
	[string] [Parameter(Mandatory=$true)] $SubscriptionId
)
Set-StrictMode -Version 3
$ErrorActionPreference = "Stop"

# DEPENDENCY (clone from https://github.com/ChackDan/Service-Fabric/tree/master/Scripts/ServiceFabricRPHelpers)
$helpersPath = "C:\Users\razidare\Documents\Azure\PowerShell_KeyVaultCert_Script\ServiceFabricRPHelpers.psm1"

# ======= dont change anything below here =======
$certificateName =      $clusterName + $certVersion
$vaultName =            $clusterName + "KeyVault" + $certVersion
$resourceGroupName =    $clusterName + "KeyVaultGroup"
$certificateNamePath =  $outputPath + "\" + $certificateName + ".pfx"
$dnsName =              $clusterName + "." + $location + ".cloudapp.azure.com"

Import-Module $helpersPath
$password1 = (Read-Host -AsSecureString -Prompt "Enter Certificate Password ")
$password2 = (Read-Host -AsSecureString -Prompt "Re-Enter Certificate Password ")

Login-AzureRmAccount
Set-AzureRmContext -SubscriptionId $subscriptionId
New-AzureRmResourceGroup -Name $resourceGroupName -Location $location
New-AzureRmKeyVault -VaultName $vaultName -ResourceGroupName $resourceGroupName -Location $location

Set-AzureRmKeyVaultAccessPolicy -VaultName $vaultName -ResourceGroupName $resourceGroupName -EnabledForDeployment
$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password1)
$verifiedPassword1 = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) 
$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password2)
$verifiedPassword2 = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR) 
If($verifiedPassword1 -eq $verifiedPassword2)
{
	$keyVaultInfo = $outputPath + "\" + $certificateName + ".txt"
	New-Item -ItemType Directory -Force -Path $outputPath
	    Invoke-AddCertToKeyVault -SubscriptionId $subscriptionId -ResourceGroupName $resourceGroupName -Location $location -VaultName $vaultName -CertificateName $certificateName -Password $verifiedPassword1 -CreateSelfSignedCertificate -DnsName $dnsName -OutputPath $outputPath | Out-File $keyVaultInfo
	Get-Content $keyVaultInfo
	    Import-PfxCertificate -Exportable -CertStoreLocation Cert:\CurrentUser\TrustedPeople -FilePath $certificateNamePath -Password $password1
	    Import-PfxCertificate -Exportable -CertStoreLocation Cert:\CurrentUser\My -FilePath $certificateNamePath -Password $password1
} Else {
	    Write-Host "Passwords did not match, exiting."
}
$BSTR = ""
$verifiedPassword1 = ""
$verifiedPassword2 = ""
Write-Host "operation complete"
